/*********************************************************************************************************//**
* @file 
*  miclib_misc.c
* @author
*  JangHo, Yoo
* @date
*  2012.08.20
* @brief
*  이 파일은 MICLIB의 공용 매크로들과 공용함수들에 대해 기술한다.
*************************************************************************************************************/
/*************************************************************************************************************
* INCLUDE FILES
*************************************************************************************************************/
#include "miclib_type.h"
#include "miclib_misc.h"

/*************************************************************************************************************
* LOCAL DEFINES
*************************************************************************************************************/

/*************************************************************************************************************
* LOCAL CONSTANTS
*************************************************************************************************************/

/*************************************************************************************************************
* LOCAL DATA TYPES
*************************************************************************************************************/
#if USE_BASIC_TYPE == 0
typedef signed char              int08;
typedef unsigned char            uint08;
typedef signed short             int16;
typedef unsigned short           uint16;
typedef signed long              int32;
typedef unsigned long            uint32;
#endif

/*************************************************************************************************************
* LOCAL TABLES
*************************************************************************************************************/

/*************************************************************************************************************
* LOCAL GLOBAL VARIABLES
*************************************************************************************************************/

/*************************************************************************************************************
* LOCAL FUNCTION PROTOTYPES
*************************************************************************************************************/

/*************************************************************************************************************
* LOCAL CONFIGURATION ERRORS
*************************************************************************************************************/

/*************************************************************************************************************
**************************************************************************************************************
* LOCAL FUNCTIONS
**************************************************************************************************************
*************************************************************************************************************/

/*************************************************************************************************************
**************************************************************************************************************
* GLOBAL FUNCTIONS
**************************************************************************************************************
*************************************************************************************************************/
/*********************************************************************************************************//**
* @param[in]
*   arga : ascii code ('0'~'9', 'A'~'F', 'a' ~ 'f')
* @retval
*   binary data
* @brief
*   입력된 ascii code를 binary 값으로 변환한다.
*************************************************************************************************************/
#if USE_MICLIB_ASC2BIN > 0
uint08 asc2bin(uint08 arga)
{
	uint08 bin_t = 0;

	if (arga <= '9')
	{
		bin_t = arga - '0';
	}
	else if ((arga >= 'A') && (arga <= 'F'))
	{
		bin_t = arga - 'A' + 10;
	}
	else if ((arga >= 'a') && (arga < 'f'))
	{
		bin_t = arga - 'a' + 10;
	}
	else
	{
		bin_t = 0xFF;                             /* Error */
	}
	
	return (bin_t);
} /* asc2bin */
#endif

/*********************************************************************************************************//**
* @param[in]
*   arga : binary code (0x00 ~ 0x0F)
* @retval
*   ASCII Code
* @brief
*   입력된 binary값에 대한 Ascii-Code(Upper case)를 반환한다.
*************************************************************************************************************/
#if USE_MICLIB_BIN2ASC > 0
uint08 bin2asc(uint08 arga)
{
	uint08 asc_t;

	if (arga < 10)
	{
		asc_t = arga + '0';
	}
	else
	{
		asc_t = arga - 10 + 'A';
	}
	
	return (asc_t);
} /* bin2ascu */
#endif

/*********************************************************************************************************//**
* @param[in]
*  *src : byte 값으로변경할 소스(ascii)데이터 버퍼 포인터
*  idx : 소스데이터 버퍼의 byte 값으로 변경할 버퍼 인덱스 
*  len : byte 값으로 변경할 ascii byte의 길이. 최대 32bit(4byte) 가능함. (1 ~ 8)
* @retval
*  binary data(max 4byte)
* @brief
*  입력된 ascii 버퍼의 값을 idx부터 len만큼 byte값으로 변경한다.
*************************************************************************************************************/
#if USE_MICLIB_ASC2BYTES > 0
uint32 asc2bytes(uint08* asc_src, uint08 idx, uint08 len)
{
	uint08 i;
	uint32 byte_t;

	byte_t = 0;
	for (i = 0; i < len; i++)
	{
		byte_t <<= 4;
		byte_t  |= (uint32)asc2bin(*(asc_src+i+idx));
	}

	return byte_t;	
} /* asc2bytes */
#endif

/*********************************************************************************************************//**
* @param[in]
*  new : ascii 값으로 변경할 데이터
*  *asc_dest : ascii 값을 저장할 버퍼 포인터
*  idx : ascii 값으로 변경할 버퍼 인덱스 
*  len : ascii 값으로 변경할 바이트 수 최대 32bit(4byte) 가능함.
* @retval
*  binary data(max 4byte)
* @brief
*  입력된 byte값을 asc_dest버퍼에 idx부터 len만큼 ascii 값으로 변경하여 asc_dest에 반환한다.
*************************************************************************************************************/
#if USE_MICLIB_BYTES2ASC > 0
void bytes2asc(uint32 new, uint08* asc_dest, uint08 idx, uint08 len)
{
	uint08 i;
	
	for (i = 0; i < len; i++)
	{
		asc_dest[idx+len-1-i] = bin2asc((uint08)(new & 0x0F));
		new >>= 4;
	}
} /* bytes2asc */
#endif

/*********************************************************************************************************//**
* @param[in]
*   cur : 현제의 값
*   min : 최소값
*   max : 최대값
*   opt :
*     NEXT_VAL_INC : 다음 값 1증가         
*     NEXT_VAL_DEC : 다음 값 1감소
*     NEXT_VAL_ROTATE : 다음 값은 min 혹은 max로 회전 
*     NEXT_VAL_LIMIT_INC : max값에 재한되고 1증가
*     NEXT_VAL_LIMIT_DEC : min값에 제한되고 1감소
*     NEXT_VAL_ROTATE_INC : 1증가하고 min값으로 회전
*     NEXT_VAL_ROTATE_DEC : 1감소하고 max값으로 회전
* @retval
*   현재값에 대한 다음 값 
* @brief
*   현재값이 min/max의 범위내에서 혹은 회전하도록 다음 값을 opt에 따라 변경한다. 
*************************************************************************************************************/
#if USE_MICLIB_GETNEXTVAL > 0
int16 GetNextValue(int16 cur, int16 min, int16 max, uint08 opt)
{
	int16 next;

	next = cur;

	if (opt & NEXT_VAL_ROTATE)
	{
		(opt & NEXT_VAL_INC) ? next++ : next--;
		if (next < min) next = max;
		if (next > max) next = min;
	}
	else
	{
		(opt & NEXT_VAL_INC) ? next++ : next--;
		if (next < min) next = min;
		if (next > max) next = max;
	}

	return next;
} /* GetNextValue */
#endif

/*********************************************************************************************************//**
* @param[in]
*   xp : x0, x1사이의 임의의 x축의 값
*   x0 : x0  (x0 <= xp)
*   x1 : x1  (x1 >= xp)
*   y0 : x0점의 y값
*   y1 : x1점의 y값
* @retval
*   x0, x1사이의 임의의 점 xp에 대한 선형보간값
* @brief
*   입력된 (x0, x1) 사이의 임의의 점 xp에 대한 선형보간값을 구한다.
*              (y1 - y0) * (xp - x0)
*   y := y0 + -----------------------
*                   (x1 - x0)
*************************************************************************************************************/
#if USE_MICLIB_LINEARINTERP > 0
int32 CalcLinearInterpolation(int32 xp, int32 x0, int32 x1, int32 y0, int32 y1)
{
	int32 y_xp;
	
	if (xp <= x0)
	{
		y_xp = y0;
	}
	else if (xp >= x1)
	{
		y_xp = y1;
	}
	else
	{
		y_xp = y0 + ((y1 - y0) * (xp - x0)) / (x1 - x0);
	}

	return (y_xp);	
} /* CalcLinearInterpolation */
#endif

/*********************************************************************************************************//**
* @param[in]
*  new_val : 새로 추가할 현재의 데이터
*  *pb     : 데이터 버퍼
*    n     : 차수 
* @retval
*  단순 이동평균값
* @brief
*  단순 이동평균을 연산
*          (pb[0] + pb[1] + ... + pb[n-1])
*  Y[n] =  -------------------------------
*                         n
**************************************************************************************************************/
#if USE_MICLIB_SMA > 0
uint32 CalcSimpleMovingAvg(uint32 new_val, uint32 *pb, uint32 n)
{
	uint32  m_sum;
	uint32  i;

	for (i = (n - 1); i >= 0; i--)
	{
		pb[i+1] = pb[i];
	}
	pb[0] = new_val;

	m_sum = 0;
	for (i = 0; i < n; i++, pb++)
	{
		m_sum = m_sum + *pb;
	}	

	return (m_sum / n);
} /* CalcSimpleMovingAvg */
#endif

/*********************************************************************************************************//**
* @param[in]
*  new_val : 새로 추가할 현재의 데이터
*  *pb     : 데이터 버퍼 포인터
*  n       : 차수
* @retval
*  가중이동평균값 
* @brief
*  가중이동평균값을 연산한다.
*         ((wght * pb[0]) + ((wght - 1) * pb[1]) + ((wght - 2) * pb[2]) + ... + ((wght - n + 1) * pb[n])
* Y[n] = ------------------------------------------------------------------------------------------------
*                               ((wght + (wght - 1) + ... + (wght - n + 1))
**************************************************************************************************************/
#if USE_MICLIB_WMA > 0
uint32 CalcWeightedMovingAvg(uint32 new_val, uint32 *pb, uint32 n)
{ 
	uint32  n_sum;
	uint32  i;
	uint32  w_sum;
	uint32  wght;

	for (i = (n - 1); i >= 0; i--)
	{
		pb[i+1] = pb[i];
	}
	pb[0] = new_val;

	n_sum = 0;
	for (i = 0; i < n; i++)
	{
		n_sum += (i + 1);
	}

	w_sum = 0;
	wght  = n;
	for (i = 0; i < n; i++, pb++)
	{
		w_sum += (wght * *pb);
		wght--;
	}

	return (w_sum / n_sum);
} /* CalcWeightedMovingAvg */
#endif

/*********************************************************************************************************//**
* @param[in]
*  *pb_s   : 입력 데이터 버퍼 포인터
*  n       : 차수
*  tap     : 필터 탭수 
*  *pb_avg : 출력 데이터 버퍼 포인터 (이동평균 데이터)
* @retval
*  None 
* @brief
*  입력 데이터에 대한 이동평균필터
**************************************************************************************************************/
#if USE_MICLIB_MAF > 0
void MovingAvgFilter(uint32 *pb_s, uint32 n, uint32 tap, uint32 *pb_avg)
{
	uint32 i, j;
	uint32 idx;

	for (i = 0; i < n; i++, pb_avg++)
	{	
		for (j = 0; j < tap; j++, pb_s++)
		{
			idx = i + j;
			
			if (idx < n)
			{
				*pb_avg += (*(pb_s+i));
			}
		}
		*pb_avg /= tap;
	}
} /* MovingAvgFilter */
#endif

/*********************************************************************************************************//**
* @param[in]
*   *pb : 정렬할 데이터 버퍼 포인터
*   n   : 데이터의 개수
* @retval
*   None
* @brief
*  데이터 버퍼배열의 내용을 오름차순으로 정렬한다.
**************************************************************************************************************/
#if USE_MICLIB_ASCENDSORT > 0
void AscendSort(uint32 *pb, uint32 n)
{
	uint32 temp;
	uint32 i, j;

	for (i = 0; i < n; i++)
	{
		for (j = i+1; j < n; j++)
		{
			if (pb[i] > pb[j])
			{
				temp  = pb[i];
				pb[i] = pb[j];
				pb[j] = temp;
			}
		}
	}	
} /* AscendSort */
#endif

/*********************************************************************************************************//**
* @param[in]
*   *pb : 정렬할 데이터 버퍼 포인터
*   n   : 데이터의 개수
* @retval
*   None
* @brief
*  데이터 버퍼배열의 내용을 내림차순으로 정렬한다.
**************************************************************************************************************/
#if USE_MICLIB_DESCNDSORT > 0
void DescendSort(uint32 *pb, uint32 n)
{
	uint32 temp;
	uint32 i, j;
	
	for (i = 0; i < n; i++)
	{
		for (j = i+1; j < n; j++)
		{
			if (pb[i] < pb[j])
			{
				temp = pb[i];
				pb[i] = pb[j];
				pb[j] = temp;
			}
		}
	}
} /* DescendSort */
#endif

/*********************************************************************************************************//**
* @param[in]
*   *dst : destination address
*   *src : source address
*   n : size
* @retval
*   destication address
* @brief
*  메모리 영역 복사
**************************************************************************************************************/
#if USE_MICLIB_MEMCPY > 0
void *
memcpy2(void *dst, void *src, int n)
{
	char *d = dst, *s = src;

	while(n--)
	{
		*d++ = *s++;
	}

	return dst;
	
}
#endif





/********************************************* END OF FILE **************************************************/
